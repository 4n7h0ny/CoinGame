<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>The Bosses – Created by Kai Nava</title>

  <style>
    body {
      margin: 0;
      background: #222;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      overflow: hidden;
      user-select: none;
      font-family: system-ui, sans-serif;
    }
    canvas {
      border: 4px solid white;
      border-radius: 8px;
      background: #87ceeb;
    }
  </style>
</head>
<body>
<canvas id="game" width="900" height="500"></canvas>

<script>
/* ======================================================================
   THE BOSSES – Created by Kai Nava
   Two-level platformer with characters, coins, enemies, and boss battle
   ====================================================================== */

const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

let gameState = "title";
let characterChoice = "bart";
let facingDir = 1;
const maxLevelRetries = 3;
let retriesLeft = maxLevelRetries;

const keys = {};
document.addEventListener("keydown", e => {
  keys[e.code] = true;

  if (gameState === "dead" && e.code === "KeyR" && retriesLeft > 0) {
    retriesLeft--;
    restartLevel();
  }
});
document.addEventListener("keyup", e => keys[e.code] = false);

async function resumeAudioContext() {
  if (audioContext.state === "suspended") {
    await audioContext.resume();
  }
}

canvas.addEventListener("click", async () => {
  await resumeAudioContext();

  if (gameState === "win") {
    resetGame();
  }
  if (gameState === "dead") {
    if (retriesLeft > 0) {
      retriesLeft--;
      restartLevel();
    } else {
      resetGame();
    }
  }
  if (gameState === "title") {
    gameState = "characterSelect";
  }
});

/* ======================================================================
   AUDIO SETUP
   ====================================================================== */

const audioContext = new (window.AudioContext || window.webkitAudioContext)();
let musicPlaying = false;

function playTone(freq, duration, vol = 0.1) {
  const osc = audioContext.createOscillator();
  const gain = audioContext.createGain();
  osc.connect(gain);
  gain.connect(audioContext.destination);
  
  osc.frequency.value = freq;
  gain.gain.value = vol;
  
  osc.start();
  osc.stop(audioContext.currentTime + duration);
}

function startMusic() {
  if (musicPlaying) return;
  musicPlaying = true;
  
  const melody = [262, 294, 330, 349, 392, 440, 494, 523];
  let noteIndex = 0;
  
  function playNextNote() {
    if (!musicPlaying || gameState === "title") return;
    playTone(melody[noteIndex % melody.length], 0.3, 0.05);
    noteIndex++;
    setTimeout(playNextNote, 400);
  }
  
  playNextNote();
}

function playJumpSound() {
  playTone(440, 0.1, 0.08);
}

function playCoinSound() {
  playTone(660, 0.15, 0.1);
}

function playHitSound() {
  playTone(150, 0.2, 0.12);
}

/* ======================================================================
   PLAYER DEFINITIONS
   ====================================================================== */

const player = {
  x: 50,
  y: 350,
  vx: 0,
  vy: 0,
  r: 18,
  onGround: false,
  speed: 6,
  jumpVel: -14,
  coins: 0,
  health: 3,
  invincible: 0,
  shots: [],
  shotCooldown: 0
};

/* ======================================================================
   LEVEL DATA
   ====================================================================== */

let currentLevel = 1;

const boss = {
  x: 2400,
  y: 200,
  health: 8,
  maxHealth: 8,
  phase: 1,
  dir: -1,
  attackTimer: 0,
  projectiles: [],
  active: false
};

const levels = {
  1: {
    width: 2500,
    platforms: [
      {x:0, y:430, w:600, h:50},
      {x:650, y:430, w:300, h:50},
      {x:1000, y:430, w:400, h:50},
      {x:1500, y:430, w:350, h:50},
      {x:1900, y:380, w:300, h:50},
      {x:2300, y:330, w:200, h:50}
    ],
    coins: [
      {x:300, y:360, taken:false},
      {x:720, y:360, taken:false},
      {x:1100, y:360, taken:false},
      {x:1650, y:360, taken:false},
      {x:2100, y:300, taken:false}
    ],
    enemies: [
      {x:800, y:380, w:40, h:40, dir:1, min:750, max:900},
      {x:1600, y:380, w:40, h:40, dir:-1, min:1500, max:1700}
    ],
    finish: {x:2400, y:280, w:150, h:20}
  },

  2: {
    width: 2800,
    platforms: [
      {x:0, y:430, w:600, h:50},
      {x:700, y:350, w:250, h:40},
      {x:1100, y:280, w:200, h:40},
      {x:1500, y:220, w:300, h:40},
      {x:1900, y:300, w:300, h:40},
      {x:2350, y:380, w:350, h:40}
    ],
    coins: [
      {x:250, y:360, taken:false},
      {x:760, y:300, taken:false},
      {x:1150, y:220, taken:false},
      {x:1600, y:160, taken:false},
      {x:2000, y:240, taken:false},
      {x:2500, y:330, taken:false}
    ],
    enemies: [
      {x:720, y:310, w:40, h:40, dir:1, min:700, max:850},
      {x:1550, y:190, w:40, h:40, dir:1, min:1500, max:1750},
      {x:2400, y:350, w:40, h:40, dir:-1, min:2350, max:2600}
    ],
    finish: {x:2650, y:340, w:150, h:20}
  },

  3: {
    width: 3000,
    platforms: [
      {x:0, y:430, w:400, h:50},
      {x:500, y:430, w:400, h:50},
      {x:1000, y:430, w:400, h:50},
      {x:1500, y:430, w:400, h:50},
      {x:2000, y:430, w:400, h:50},
      {x:2500, y:430, w:500, h:50}
    ],
    coins: [],
    enemies: [],
    finish: null,
    isBossLevel: true
  }
};

/* ======================================================================
   RESET GAME
   ====================================================================== */
function resetGame() {
  player.x = 50;
  player.y = 350;
  player.vx = 0;
  player.vy = 0;
  player.coins = 0;
  player.health = 3;
  player.invincible = 0;
  player.shots = [];
  player.shotCooldown = 0;

  currentLevel = 1;
  retriesLeft = maxLevelRetries;

  boss.health = boss.maxHealth;
  boss.phase = 1;
  boss.projectiles = [];
  boss.active = false;
  boss.x = 2400;
  boss.y = 200;

  for (let lvl of [1,2,3]) {
    if (!levels[lvl]) continue;
    for (let c of levels[lvl].coins)
      c.taken = false;

    for (let e of levels[lvl].enemies) {
      e.dir = 1;
      e.x = e.min;
      e.defeated = false;
    }
  }

  musicPlaying = false;
  gameState = "title";
}

function restartLevel() {
  player.x = 50;
  player.y = 350;
  player.vx = 0;
  player.vy = 0;
  player.health = 3;
  player.invincible = 0;
  player.shots = [];
  player.shotCooldown = 0;

  // reset collectibles and enemy positions for current level
  const lvl = levels[currentLevel];
  for (let c of lvl.coins) c.taken = false;
  for (let e of lvl.enemies) { e.dir = 1; e.x = e.min; e.defeated = false; }

  // reset boss state when retrying level 3
  if (currentLevel === 3) {
    boss.health = boss.maxHealth;
    boss.phase = 1;
    boss.projectiles = [];
    boss.active = true;
    boss.dir = -1;
    boss.attackTimer = 0;
    boss.x = 2400;
    boss.y = 200;
  }

  gameState = "play";
  musicPlaying = false;
  startMusic();
}

/* ======================================================================
   PHYSICS
   ====================================================================== */

function applyPhysics() {
  player.vy += 0.7;

  if (keys["ArrowLeft"]) { player.vx = -player.speed; facingDir = -1; }
  else if (keys["ArrowRight"]) { player.vx = player.speed; facingDir = 1; }
  else player.vx = 0;

  if (player.shotCooldown > 0) player.shotCooldown--;
  if (keys["KeyF"] && player.shotCooldown === 0) {
    player.shots.push({ x: player.x, y: player.y - 5, vx: facingDir * 10, r: 8, ttl: 90 });
    player.shotCooldown = 18;
    playTone(520, 0.1, 0.09);
  }

  if (player.onGround && keys["Space"]) {
    player.vy = player.jumpVel;
    playJumpSound();
  }

  player.x += player.vx;
  player.y += player.vy;

  // Check if player fell off the map
  if (player.y > 600) {
    player.health = 0;
    gameState = "dead";
    musicPlaying = false;
  }

  if (player.invincible > 0) player.invincible--;

  handlePlatforms();
  handleCoins();
  handleEnemies();
  handleShots();
  handleFinish();

  if (currentLevel === 3 && boss.active) {
    updateBoss();
  }
}

/* ======================================================================
   PLATFORM COLLISIONS
   ====================================================================== */
function handlePlatforms() {
  const platList = levels[currentLevel].platforms;
  player.onGround = false;

  for (let p of platList) {
    if (player.x + player.r > p.x &&
        player.x - player.r < p.x + p.w &&
        player.y + player.r > p.y &&
        player.y - player.r < p.y + p.h) {

      if (player.vy > 0 && player.y < p.y) {
        player.y = p.y - player.r;
        player.vy = 0;
        player.onGround = true;
      }
    }
  }
}

/* ======================================================================
   COINS
   ====================================================================== */
function handleCoins() {
  for (let c of levels[currentLevel].coins) {
    if (c.taken) continue;
    let dx = player.x - c.x;
    let dy = player.y - c.y;
    if (dx*dx + dy*dy < 30*30) {
      c.taken = true;
      player.coins++;
      playCoinSound();
    }
  }
}

/* ======================================================================
   ENEMY COLLISION
   ====================================================================== */
function handleEnemies() {
  for (let e of levels[currentLevel].enemies) {
    if (e.defeated) continue;

    e.x += e.dir * 2;
    if (e.x < e.min || e.x > e.max) e.dir *= -1;

    if (player.invincible > 0) continue;

    if (player.x + player.r > e.x &&
        player.x - player.r < e.x + e.w &&
        player.y + player.r > e.y &&
        player.y - player.r < e.y + e.h) {

      player.health--;
      player.invincible = 60;
      playHitSound();

      if (player.health <= 0) {
        gameState = "dead";
        musicPlaying = false;
      }
    }
  }
}

/* ======================================================================
   PLAYER PROJECTILES
   ====================================================================== */
function handleShots() {
  for (let i = player.shots.length - 1; i >= 0; i--) {
    const s = player.shots[i];
    s.x += s.vx;
    s.ttl--;

    if (s.ttl <= 0 || s.x < -50 || s.x > levels[currentLevel].width + 50) {
      player.shots.splice(i, 1);
      continue;
    }

    // Hit enemies
    for (let e of levels[currentLevel].enemies) {
      if (e.defeated) continue;
      if (s.x + s.r > e.x && s.x - s.r < e.x + e.w &&
          s.y > e.y - 30 && s.y < e.y + e.h + 30) { // vertical leniency
        e.defeated = true;
        player.shots.splice(i, 1);
        playHitSound();
        break;
      }
    }

    // Hit boss
    if (currentLevel === 3 && boss.active) {
      const dx = s.x - boss.x;
      const dy = s.y - boss.y;
      if (Math.abs(dx) < 60 && Math.abs(dy) < 70) {
        boss.health--;
        player.shots.splice(i, 1);
        playTone(720, 0.12, 0.12);

        if (boss.health <= 0) {
          gameState = "win";
          musicPlaying = false;
        }
      }
    }
  }
}

/* ======================================================================
   FINISH FLAG
   ====================================================================== */
function handleFinish() {
  const f = levels[currentLevel].finish;
  if (!f) return;

  if (player.x > f.x && player.x < f.x + f.w &&
      player.y > f.y && player.y < f.y + f.h) {

    if (currentLevel === 1) {
      currentLevel = 2;
      player.x = 50;
      player.y = 350;
    } else if (currentLevel === 2) {
      currentLevel = 3;
      player.x = 50;
      player.y = 350;
      boss.active = true;
    }
  }
}

/* ======================================================================
   BOSS BATTLE
   ====================================================================== */

function updateBoss() {
  boss.attackTimer++;

  // Boss movement
  boss.x += boss.dir * 1.5;
  if (boss.x < 2100 || boss.x > 2700) boss.dir *= -1;

  // Phase changes
  if (boss.health < boss.maxHealth * 0.5 && boss.phase === 1) {
    boss.phase = 2;
  }

  // Attack pattern
  const attackSpeed = boss.phase === 1 ? 80 : 50;
  
  if (boss.attackTimer > attackSpeed) {
    boss.attackTimer = 0;
    
    // Shoot projectile toward player
    const angle = Math.atan2(player.y - boss.y, player.x - boss.x);
    boss.projectiles.push({
      x: boss.x,
      y: boss.y + 30,
      vx: Math.cos(angle) * 4,
      vy: Math.sin(angle) * 4,
      r: 10
    });
  }

  // Update projectiles
  for (let i = boss.projectiles.length - 1; i >= 0; i--) {
    const p = boss.projectiles[i];
    p.x += p.vx;
    p.y += p.vy;

    // Remove off-screen projectiles
    if (p.x < -50 || p.x > 3050 || p.y < -50 || p.y > 550) {
      boss.projectiles.splice(i, 1);
      continue;
    }

    // Check collision with player
    if (player.invincible > 0) continue;
    
    const dx = player.x - p.x;
    const dy = player.y - p.y;
    if (dx*dx + dy*dy < (player.r + p.r) * (player.r + p.r)) {
      player.health--;
      player.invincible = 60;
      playHitSound();
      boss.projectiles.splice(i, 1);

      if (player.health <= 0) {
        gameState = "dead";
        musicPlaying = false;
      }
    }
  }

  // Check if player hits boss (jump on head)
  if (player.vy > 0 &&
      player.x > boss.x - 40 && player.x < boss.x + 80 &&
      player.y + player.r > boss.y - 20 && player.y < boss.y + 20) {
    
    boss.health--;
    player.vy = -10;
    playTone(800, 0.15, 0.1);

    if (boss.health <= 0) {
      gameState = "win";
      musicPlaying = false;
    }
  }

  // Contact damage if player runs into the boss body
  const touchingBoss =
    player.x + player.r > boss.x - 40 &&
    player.x - player.r < boss.x + 40 &&
    player.y + player.r > boss.y &&
    player.y - player.r < boss.y + 80;

  if (touchingBoss && player.invincible === 0) {
    player.health--;
    player.invincible = 60;
    player.vx = boss.dir * 5;
    playHitSound();

    if (player.health <= 0) {
      gameState = "dead";
      musicPlaying = false;
    }
  }
}

/* ======================================================================
   DRAW FUNCTIONS
   ====================================================================== */

function drawCharacterBall(x, y, r, type) {
  const grad = ctx.createRadialGradient(x - 6, y - 6, r * 0.2, x, y, r);
  if (type === "bart") { grad.addColorStop(0, "#ffe066"); grad.addColorStop(1, "#d49000"); }
  if (type === "lisa") { grad.addColorStop(0, "#fff28a"); grad.addColorStop(1, "#d4a300"); }
  if (type === "unicorn") { grad.addColorStop(0, "#fff"); grad.addColorStop(1, "#d8d8ff"); }

  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.arc(x, y, r, 0, Math.PI * 2);
  ctx.fill();
  ctx.lineWidth = 3;
  ctx.strokeStyle = "rgba(0,0,0,0.25)";
  ctx.stroke();

  // face
  ctx.fillStyle = "#2b2b2b";
  ctx.beginPath();
  ctx.arc(x - 6, y - 4, 3, 0, Math.PI * 2);
  ctx.arc(x + 6, y - 4, 3, 0, Math.PI * 2);
  ctx.fill();
  ctx.strokeStyle = "#2b2b2b";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(x, y + 5, 6, 0, Math.PI);
  ctx.stroke();

  if (type === "bart") {
    ctx.fillStyle = "#ff9f1c";
    ctx.fillRect(x - 14, y - r - 10, 28, 12);
    ctx.fillStyle = "#f25f5c";
    ctx.fillRect(x - 14, y - r - 14, 8, 6);
    ctx.fillRect(x + 6, y - r - 14, 8, 6);
  }
  if (type === "lisa") {
    ctx.fillStyle = "#ffd447";
    for (let i = 0; i < 10; i++)
      ctx.fillRect(x - 3 + Math.cos(i * 0.63) * (r + 4),
                   y - r + Math.sin(i * 0.63) * (r + 4),
                   5, 8);
    ctx.fillStyle = "#ff7d00";
    ctx.beginPath();
    ctx.arc(x, y + r - 4, 8, 0, Math.PI * 2);
    ctx.fill();
  }
  if (type === "unicorn") {
    ctx.fillStyle = "#f78fb3";
    ctx.beginPath();
    ctx.moveTo(x, y - r - 14);
    ctx.lineTo(x + 8, y - r + 2);
    ctx.lineTo(x - 8, y - r + 2);
    ctx.fill();
    ctx.fillStyle = "#9b5de5";
    ctx.fillRect(x - 6, y - r - 4, 12, 6);
  }
}

function drawCoin(c) {
  if (c.taken) return;
  const g = ctx.createRadialGradient(c.x - 4, c.y - 6, 4, c.x, c.y, 14);
  g.addColorStop(0, "#fff7b2");
  g.addColorStop(1, "#d9a000");
  ctx.fillStyle = g;
  ctx.beginPath();
  ctx.arc(c.x, c.y, 12, 0, Math.PI * 2);
  ctx.fill();
  ctx.strokeStyle = "#7a5600";
  ctx.lineWidth = 2;
  ctx.stroke();
}

function drawEnemy(e) {
  const gradient = ctx.createLinearGradient(e.x, e.y, e.x, e.y + e.h);
  gradient.addColorStop(0, "#ff6b6b");
  gradient.addColorStop(1, "#c81d25");
  ctx.fillStyle = gradient;
  ctx.fillRect(e.x, e.y, e.w, e.h);
  ctx.fillStyle = "#1c1c1c";
  ctx.fillRect(e.x + 6, e.y + 10, 8, 8);
  ctx.fillRect(e.x + e.w - 14, e.y + 10, 8, 8);
  ctx.fillStyle = "#ffd166";
  ctx.fillRect(e.x + e.w / 2 - 6, e.y + e.h - 10, 12, 6);
}

function drawBoss(camX) {
  const bodyGrad = ctx.createLinearGradient(0, boss.y, 0, boss.y + 80);
  bodyGrad.addColorStop(0, boss.phase === 2 ? "#ff4d6d" : "#ff7b00");
  bodyGrad.addColorStop(1, boss.phase === 2 ? "#a10030" : "#c02626");
  ctx.fillStyle = bodyGrad;
  ctx.fillRect(boss.x - camX - 45, boss.y, 90, 90);
  ctx.strokeStyle = "#2a0a0a";
  ctx.lineWidth = 3;
  ctx.strokeRect(boss.x - camX - 45, boss.y, 90, 90);

  // Boss eyes
  ctx.fillStyle = "#ffe066";
  ctx.fillRect(boss.x - camX - 25, boss.y + 25, 16, 16);
  ctx.fillRect(boss.x - camX + 8, boss.y + 25, 16, 16);
  ctx.fillStyle = "#1b1b1b";
  ctx.fillRect(boss.x - camX - 19, boss.y + 31, 6, 6);
  ctx.fillRect(boss.x - camX + 14, boss.y + 31, 6, 6);

  // Horns
  ctx.fillStyle = "#f4f1de";
  ctx.beginPath();
  ctx.moveTo(boss.x - camX - 30, boss.y);
  ctx.lineTo(boss.x - camX - 10, boss.y - 18);
  ctx.lineTo(boss.x - camX - 5, boss.y + 5);
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(boss.x - camX + 30, boss.y);
  ctx.lineTo(boss.x - camX + 10, boss.y - 18);
  ctx.lineTo(boss.x - camX + 5, boss.y + 5);
  ctx.fill();

  // Health bar
  ctx.fillStyle = "rgba(0,0,0,0.5)";
  ctx.fillRect(boss.x - camX - 50, boss.y - 30, 100, 14);

  ctx.fillStyle = boss.health > boss.maxHealth * 0.3 ? "#7cf17c" : "#ff4d6d";
  const healthWidth = (boss.health / boss.maxHealth) * 100;
  ctx.fillRect(boss.x - camX - 50, boss.y - 30, Math.max(0, healthWidth), 14);

  // Projectiles
  for (let p of boss.projectiles) {
    const fireGrad = ctx.createRadialGradient(p.x - camX, p.y, 2, p.x - camX, p.y, p.r);
    fireGrad.addColorStop(0, "#fff3b0");
    fireGrad.addColorStop(1, "#ff4800");
    ctx.fillStyle = fireGrad;
    ctx.beginPath();
    ctx.arc(p.x - camX, p.y, p.r, 0, Math.PI * 2);
    ctx.fill();
  }
}

function drawHUD() {
  ctx.fillStyle = "rgba(0,0,0,0.5)";
  ctx.fillRect(10, 10, 250, 50);

  ctx.fillStyle = "white";
  ctx.font = "18px sans-serif";
  ctx.fillText("Coins: " + player.coins, 20, 35);
  
  // Health hearts
  ctx.fillStyle = "red";
  for (let i = 0; i < player.health; i++) {
    ctx.fillText("❤", 150 + i * 25, 35);
  }

  // Level indicator
  ctx.fillText("Level: " + currentLevel, 20, 55);

  // Retries
  ctx.fillText("Retries: " + retriesLeft, 150, 55);

  if (currentLevel === 3 && boss.active) {
    ctx.fillStyle = "rgba(0,0,0,0.6)";
    ctx.fillRect(canvas.width - 220, 10, 210, 60);
    ctx.fillStyle = "#FFD700";
    ctx.font = "16px sans-serif";
    ctx.fillText("Boss health: " + boss.health + "/" + boss.maxHealth, canvas.width - 210, 35);
    ctx.fillStyle = "#7cf17c";
    ctx.fillRect(canvas.width - 210, 42, (boss.health / boss.maxHealth) * 190, 8);
    ctx.strokeStyle = "#333";
    ctx.strokeRect(canvas.width - 210, 42, 190, 8);
    ctx.fillStyle = "white";
    ctx.fillText("Press F to fire or jump on head", canvas.width - 210, 60);
  }
}

function drawLevel() {
  const lvl = levels[currentLevel];
  const camX = Math.max(0, Math.min(player.x - 300, lvl.width - canvas.width));

  // sky
  const sky = ctx.createLinearGradient(0, 0, 0, canvas.height);
  sky.addColorStop(0, "#7fc8f8");
  sky.addColorStop(1, "#e0f3ff");
  ctx.fillStyle = sky;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // parallax hills
  ctx.fillStyle = "#8bd3dd";
  ctx.beginPath();
  ctx.moveTo(-50, 320);
  ctx.quadraticCurveTo(200, 250, 450, 320);
  ctx.quadraticCurveTo(700, 390, 1000, 320);
  ctx.lineTo(1000, canvas.height);
  ctx.lineTo(-50, canvas.height);
  ctx.fill();

  ctx.fillStyle = "#5aa9e6";
  ctx.beginPath();
  ctx.moveTo(200, 360);
  ctx.quadraticCurveTo(450, 280, 700, 360);
  ctx.quadraticCurveTo(900, 420, 1200, 360);
  ctx.lineTo(1200, canvas.height);
  ctx.lineTo(200, canvas.height);
  ctx.fill();

  // platforms
  for (let p of lvl.platforms) {
    const platX = p.x - camX;
    const grad = ctx.createLinearGradient(platX, p.y, platX, p.y + p.h);
    grad.addColorStop(0, "#2b9348");
    grad.addColorStop(1, "#15673f");
    ctx.fillStyle = grad;
    ctx.fillRect(platX, p.y, p.w, p.h);
    ctx.fillStyle = "#d0c9b5";
    ctx.fillRect(platX, p.y, p.w, 8);
    ctx.fillStyle = "rgba(0,0,0,0.25)";
    ctx.fillRect(platX, p.y + p.h - 6, p.w, 6);
  }

  // coins
  for (let c of lvl.coins) {
    drawCoin({x: c.x - camX, y: c.y, taken: c.taken});
  }

  // enemies
  for (let e of lvl.enemies) {
    drawEnemy({x: e.x - camX, y: e.y, w:e.w, h:e.h});
  }

  // player shots
  ctx.fillStyle = "#ffd166";
  for (let s of player.shots) {
    ctx.beginPath();
    ctx.arc(s.x - camX, s.y, s.r, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = "#ff6b6b";
    ctx.stroke();
  }

  // finish
  const f = lvl.finish;
  if (f) {
    ctx.fillStyle = "purple";
    ctx.fillRect(f.x - camX, f.y, f.w, f.h);
  }

  // boss
  if (currentLevel === 3 && boss.active) {
    drawBoss(camX);
  }

  // player (with invincibility flicker)
  if (player.invincible === 0 || player.invincible % 10 < 5) {
    drawCharacterBall(player.x - camX, player.y, player.r, characterChoice);
  }
}

/* ======================================================================
   TITLE SCREEN
   ====================================================================== */

function drawTitleScreen() {
  // Background gradient
  const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
  grad.addColorStop(0, "#1a1a2e");
  grad.addColorStop(1, "#16213e");
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Title
  ctx.fillStyle = "#FFD700";
  ctx.strokeStyle = "#FF6B00";
  ctx.lineWidth = 4;
  ctx.font = "bold 72px sans-serif";
  ctx.strokeText("THE BOSSES", 200, 150);
  ctx.fillText("THE BOSSES", 200, 150);

  // Subtitle
  ctx.fillStyle = "white";
  ctx.font = "24px sans-serif";
  ctx.fillText("Created by Kai Nava", 310, 190);

  // Animated characters
  const bounce = Math.sin(Date.now() / 300) * 10;
  drawCharacterBall(300, 300 + bounce, 35, "bart");
  drawCharacterBall(450, 310 + bounce * 0.7, 35, "lisa");
  drawCharacterBall(600, 305 + bounce * 1.2, 35, "unicorn");

  // Instructions
  ctx.fillStyle = "#FFD700";
  ctx.font = "28px sans-serif";
  ctx.fillText("Click to Start!", 340, 420);

  // Controls
  ctx.fillStyle = "rgba(255,255,255,0.7)";
  ctx.font = "18px sans-serif";
  ctx.fillText("Arrow Keys to Move  •  Space to Jump  •  F to Fire", 200, 470);
}

/* ======================================================================
   CHARACTER SELECT SCREEN
   ====================================================================== */

function drawCharacterSelect() {
  ctx.fillStyle = "#333";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  ctx.fillStyle = "white";
  ctx.font = "32px sans-serif";
  ctx.fillText("Choose Your Character!", 260, 60);

  drawCharacterBall(200, 250, 35, "bart");
  drawCharacterBall(450, 250, 35, "lisa");
  drawCharacterBall(700, 250, 35, "unicorn");

  ctx.font = "20px sans-serif";
  ctx.fillText("Bart-Ball", 165, 310);
  ctx.fillText("Lisa-Ball", 420, 310);
  ctx.fillText("Unicorn-Ball", 645, 310);

  canvas.onclick = function(ev) {
    const x = ev.offsetX;
    const y = ev.offsetY;

    const withinRow = y > 200 && y < 320;

    if (withinRow && x > 160 && x < 240) characterChoice = "bart";
    if (withinRow && x > 410 && x < 490) characterChoice = "lisa";
    if (withinRow && x > 660 && x < 740) characterChoice = "unicorn";

    gameState = "play";
    startMusic();
    canvas.onclick = null;
  };
}

/* ======================================================================
   MAIN LOOP
   ====================================================================== */

function loop() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  if (gameState === "title") {
    drawTitleScreen();
  }
  else if (gameState === "characterSelect") {
    drawCharacterSelect();
  }
  else if (gameState === "play") {
    applyPhysics();
    drawLevel();
    drawHUD();
  }
  else if (gameState === "dead") {
    ctx.fillStyle = "rgba(0,0,0,0.8)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    ctx.fillStyle = "red";
    ctx.font = "40px sans-serif";
    ctx.fillText("Game Over!", 330, 220);
    
    ctx.fillStyle = "white";
    ctx.font = "20px sans-serif";
    ctx.fillText("You made it to Level " + currentLevel, 320, 260);
    ctx.fillText("Coins collected: " + player.coins, 340, 290);
    if (retriesLeft > 0) {
      ctx.fillText("Press R or click to retry level (" + retriesLeft + " left)", 260, 340);
    } else {
      ctx.fillText("Click to restart from the beginning", 290, 340);
    }
  }
  else if (gameState === "win") {
    ctx.fillStyle = "rgba(0,0,0,0.8)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Victory text with glow
    ctx.shadowColor = "lime";
    ctx.shadowBlur = 20;
    ctx.fillStyle = "lime";
    ctx.font = "bold 48px sans-serif";
    ctx.fillText("YOU DEFEATED THE BOSS!", 160, 220);
    ctx.shadowBlur = 0;
    
    ctx.fillStyle = "#FFD700";
    ctx.font = "28px sans-serif";
    ctx.fillText("Total Coins: " + player.coins, 340, 280);
    
    ctx.fillStyle = "white";
    ctx.font = "20px sans-serif";
    ctx.fillText("Click to play again", 350, 340);
  }

  requestAnimationFrame(loop);
}

resetGame();
loop();

</script>
</body>
</html>
